<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tetris Industrial: Final</title>
    <style>
        :root { --red: #660000; --gray: #999999; --bg: #050505; }
        body {
            background: var(--bg); color: #fff; font-family: sans-serif;
            margin: 0; display: flex; flex-direction: column; align-items: center;
            height: 100vh; overflow: hidden; touch-action: none;
        }
        .stats { margin: 10px; font-size: 1.2rem; color: var(--red); font-weight: bold; letter-spacing: 2px; }
        canvas { background: #000; border: 3px solid #222; box-shadow: 0 0 20px rgba(102,0,0,0.4); }
        .controls {
            display: grid; grid-template-columns: repeat(3, 70px); gap: 10px; margin-top: 15px;
        }
        .btn {
            background: #111; border: 2px solid var(--red); color: #fff;
            height: 60px; display: flex; align-items: center; justify-content: center;
            border-radius: 8px; cursor: pointer; user-select: none; font-size: 1.5rem;
        }
        .btn:active { background: var(--red); }
        .wide { grid-column: span 3; height: 50px; font-size: 0.9rem; border-color: #444; }
    </style>
</head>
<body>

    <div class="stats">SCORE: <span id="score">0</span></div>
    <canvas id="tetris" width="240" height="400"></canvas>

    <div class="controls">
        <div class="btn" onpointerdown="move(-1)">◀</div>
        <div class="btn" onpointerdown="rotate()">↻</div>
        <div class="btn" onpointerdown="move(1)">▶</div>
        <div class="btn wide" onpointerdown="drop()">AŞAĞI (DROP)</div>
        <div class="btn wide" onpointerdown="hardDrop()">ANINDA İNDİR (SPACE)</div>
    </div>

    <script>
        const canvas = document.getElementById('tetris');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');

        const ROW = 20, COL = 12, SQ = 20;
        const colors = [null, '#660000', '#999999', '#660000', '#999999', '#660000', '#999999', '#440000'];

        let board = Array.from({length: ROW}, () => Array(COL).fill(0));
        let score = 0;

        const PIECES = [
            [[[1,1,1,1]], 1], // I
            [[[1,1],[1,1]], 2], // O
            [[[0,1,0],[1,1,1],[0,0,0]], 3], // T
            [[[1,1,0],[0,1,1],[0,0,0]], 4], // Z
            [[[0,1,1],[1,1,0],[0,0,0]], 5], // S
            [[[1,0,0],[1,1,1],[0,0,0]], 6], // J
            [[[0,0,1],[1,1,1],[0,0,0]], 7]  // L
        ];

        let p = randomPiece();

        function randomPiece() {
            const r = Math.floor(Math.random() * PIECES.length);
            return {
                matrix: PIECES[r][0],
                color: colors[PIECES[r][1]],
                pos: {x: 4, y: 0}
            };
        }

        function drawSquare(x, y, color, border = true) {
            ctx.fillStyle = color;
            ctx.fillRect(x * SQ, y * SQ, SQ, SQ);
            if(border) {
                ctx.strokeStyle = "#000";
                ctx.strokeRect(x * SQ, y * SQ, SQ, SQ);
            }
        }

        function draw() {
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Board
            board.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) drawSquare(x, y, value);
                });
            });

            // Ghost Piece (Gölge)
            let ghostY = p.pos.y;
            while (!collide(p.pos.x, ghostY + 1, p.matrix)) ghostY++;
            p.matrix.forEach((row, y) => {
                row.forEach((v, x) => {
                    if(v) drawSquare(x + p.pos.x, y + ghostY, "rgba(153,153,153,0.15)", false);
                });
            });

            // Player Piece
            p.matrix.forEach((row, y) => {
                row.forEach((v, x) => {
                    if(v) drawSquare(x + p.pos.x, y + p.pos.y, p.color);
                });
            });
        }

        function collide(x, y, matrix) {
            for (let r = 0; r < matrix.length; r++) {
                for (let c = 0; c < matrix[r].length; c++) {
                    if (!matrix[r][c]) continue;
                    let newX = x + c;
                    let newY = y + r;
                    if (newX < 0 || newX >= COL || newY >= ROW) return true;
                    if (newY < 0) continue;
                    if (board[newY][newX]) return true;
                }
            }
            return false;
        }

        function merge() {
            p.matrix.forEach((row, y) => {
                row.forEach((v, x) => {
                    if(v) board[y + p.pos.y][x + p.pos.x] = p.color;
                });
            });
        }

        function sweep() {
            outer: for (let y = ROW - 1; y > 0; y--) {
                for (let x = 0; x < COL; x++) {
                    if (!board[y][x]) continue outer;
                }
                const row = board.splice(y, 1)[0].fill(0);
                board.unshift(row);
                score += 100;
                y++;
            }
            scoreEl.innerText = score;
        }

        function move(dir) {
            if (!collide(p.pos.x + dir, p.pos.y, p.matrix)) p.pos.x += dir;
            draw();
        }

        function rotate() {
            const m = p.matrix;
            const newM = m[0].map((_, i) => m.map(row => row[i]).reverse());
            if (!collide(p.pos.x, p.pos.y, newM)) p.matrix = newM;
            draw();
        }

        function drop() {
            if (!collide(p.pos.x, p.pos.y + 1, p.matrix)) {
                p.pos.y++;
            } else {
                merge();
                sweep();
                p = randomPiece();
                if (collide(p.pos.x, p.pos.y, p.matrix)) {
                    alert("GAME OVER!");
                    board = Array.from({length: ROW}, () => Array(COL).fill(0));
                    score = 0;
                    scoreEl.innerText = score;
                }
            }
            draw();
        }

        function hardDrop() {
            while (!collide(p.pos.x, p.pos.y + 1, p.matrix)) p.pos.y++;
            drop();
        }

        document.addEventListener('keydown', e => {
            if (e.keyCode === 37) move(-1);
            if (e.keyCode === 39) move(1);
            if (e.keyCode === 40) drop();
            if (e.keyCode === 38) rotate();
            if (e.keyCode === 32) hardDrop();
        });

        setInterval(drop, 1000);
        draw();
    </script>
</body>
</html>